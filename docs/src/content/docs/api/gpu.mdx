---
title: GPU Support
description: Graphical output and input devices
---

import LanguageTabs from '../../../components/LanguageTabs.astro';
import LangTabItem from '../../../components/LangTabItem.astro';

CrumbleCracker supports virtio-gpu and virtio-input devices for graphical applications. This enables running desktop environments, games, and other GUI applications inside VMs.

## Overview

GPU support provides:

- **Framebuffer rendering**: Access the VM's display output
- **Keyboard input**: Send keyboard events to the VM
- **Mouse input**: Send mouse movement and clicks

## Enabling GPU

Use GPU support when creating an instance:

<LanguageTabs>
  <LangTabItem lang="go">
```go
runtime.LockOSThread() // Required for windowing on macOS

instance, err := cc.New(source, cc.WithGPU())
if err != nil {
    return err
}
defer instance.Close()
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# GPU support is available via the Go API and ccapp
# For headless rendering, consider using a virtual framebuffer
options = cc.InstanceOptions(enable_gpu=True)
inst = cc.Instance(source, options)
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// GPU support is available via the Go API and ccapp
let opts = InstanceOptions { enable_gpu: true, ..Default::default() };
let inst = Instance::new(source, Some(opts))?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// GPU support is available via the Go API and ccapp
const inst = await source.createInstance({ enableGpu: true });
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// GPU support is available via the Go API and ccapp
cc_instance_options opts = { .enable_gpu = true };
cc_instance_new(source, &opts, &inst, &err);
```
  </LangTabItem>
</LanguageTabs>

## The GPU Interface (Go API)

When GPU is enabled, `instance.GPU()` returns a non-nil interface:

<LanguageTabs>
  <LangTabItem lang="go">
```go
type GPU interface {
    SetWindow(w any)
    Poll() bool
    Render()
    Swap()
    GetFramebuffer() (pixels []byte, width, height uint32, ok bool)
}
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# GPU interface methods are available in the Go API
# Use ccapp for graphical VM management
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// GPU interface methods are available in the Go API
// Use ccapp for graphical VM management
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// GPU interface methods are available in the Go API
// Use ccapp for graphical VM management
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// GPU interface methods are available in the Go API
// Use ccapp for graphical VM management
```
  </LangTabItem>
</LanguageTabs>

## Display Loop (Go API)

You must run the display loop on the main thread:

<LanguageTabs>
  <LangTabItem lang="go">
```go
func main() {
    runtime.LockOSThread()

    instance, _ := cc.New(source, cc.WithGPU())
    defer instance.Close()

    gpu := instance.GPU()
    if gpu == nil {
        log.Fatal("GPU not available")
    }

    // Create a window (platform-specific)
    window := createWindow(800, 600)
    gpu.SetWindow(window)

    // Display loop
    for {
        if !gpu.Poll() {
            break // Window closed
        }
        gpu.Render()
        gpu.Swap()
    }
}
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# For graphical applications, use ccapp which handles the display loop
# ccapp provides a full desktop experience with window management
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// For graphical applications, use ccapp which handles the display loop
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// For graphical applications, use ccapp which handles the display loop
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// For graphical applications, use ccapp which handles the display loop
```
  </LangTabItem>
</LanguageTabs>

### Poll

Process window events (keyboard, mouse, close) and forward input to the VM:

<LanguageTabs>
  <LangTabItem lang="go">
```go
if !gpu.Poll() {
    // Window was closed
    break
}
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Event polling is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Event polling is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Event polling is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Event polling is handled by ccapp
```
  </LangTabItem>
</LanguageTabs>

### Render and Swap

Render the current framebuffer to the window:

<LanguageTabs>
  <LangTabItem lang="go">
```go
gpu.Render()
gpu.Swap()
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Rendering is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Rendering is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Rendering is handled by ccapp
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Rendering is handled by ccapp
```
  </LangTabItem>
</LanguageTabs>

## Getting Raw Framebuffer

Access the framebuffer pixels directly:

<LanguageTabs>
  <LangTabItem lang="go">
```go
pixels, width, height, ok := gpu.GetFramebuffer()
if ok {
    // pixels is in BGRA format
    // width and height are the framebuffer dimensions
    saveScreenshot(pixels, width, height)
}
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Framebuffer access is available in the Go API
# For screenshots, run a command inside the VM
output = inst.command("scrot", "-o", "/tmp/screenshot.png").run()
screenshot = inst.read_file("/tmp/screenshot.png")
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Framebuffer access is available in the Go API
// For screenshots, run a command inside the VM
inst.command("scrot", &["-o", "/tmp/screenshot.png"])?.run()?;
let screenshot = inst.read_file("/tmp/screenshot.png")?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Framebuffer access is available in the Go API
// For screenshots, run a command inside the VM
const scrotCmd = await inst.command('scrot', '-o', '/tmp/screenshot.png');
await scrotCmd.run();
const screenshot = await inst.readFile('/tmp/screenshot.png');
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Framebuffer access is available in the Go API
// For screenshots, run a command inside the VM
```
  </LangTabItem>
</LanguageTabs>

This is useful for:
- Taking screenshots
- Recording video
- Remote display streaming

## Input Handling

Input events are handled automatically by `Poll()`. The GPU interface forwards:

- Keyboard key presses and releases
- Mouse movement
- Mouse button clicks
- Mouse wheel scrolling

## Requirements

GPU support requires:

1. A display server running in the guest (X11 or Wayland)
2. Virtio-GPU drivers in the guest kernel (included in most distributions)
3. A windowing system on the host (not available in headless SSH sessions)

## Platform Notes

### macOS

- Requires `runtime.LockOSThread()` for Cocoa windowing
- Uses Metal for rendering

### Linux

- Requires a display server (X11 or Wayland)
- Uses OpenGL for rendering

### Windows

- Uses WGL for rendering
- Window creation is handled internally

## Console Size

For terminal applications, set the console size:

<LanguageTabs>
  <LangTabItem lang="go">
```go
instance.SetConsoleSize(80, 24) // columns, rows
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
inst.set_console_size(80, 24)  # columns, rows
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
inst.set_console_size(80, 24)?; // columns, rows
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
await inst.setConsoleSize(80, 24); // columns, rows
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
cc_instance_set_console_size(inst, 80, 24, &err); // columns, rows
```
  </LangTabItem>
</LanguageTabs>

This updates the virtio-console device so the guest sees the correct terminal dimensions.

## Next Steps

- [Instance Options](/cc/reference/options/) - All GPU-related options
- [ccapp Overview](/cc/app/overview/) - GUI application with built-in GPU support
