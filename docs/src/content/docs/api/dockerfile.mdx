---
title: Dockerfile
description: Build images from Dockerfiles
---

import LanguageTabs from '../../../components/LanguageTabs.astro';
import LangTabItem from '../../../components/LangTabItem.astro';

CrumbleCracker can build images directly from Dockerfile content, without requiring Docker to be installed. This is useful for creating custom images programmatically.

## Overview

<LanguageTabs>
  <LangTabItem lang="go">
```go
dockerfile := []byte(`
FROM alpine:3.19
RUN apk add --no-cache curl
COPY app /usr/local/bin/
CMD ["app"]
`)

source, err := cc.BuildDockerfileSource(ctx, dockerfile, client,
    cc.WithBuildContextDir("./build"),
)
if err != nil {
    return err
}

instance, err := cc.New(source)
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Dockerfile building is available via the Go API
# For Python, use pre-built images or snapshots

# Pull base image and customize
source = client.pull("alpine:3.19")
with cc.Instance(source) as inst:
    inst.command("apk", "add", "--no-cache", "curl").run()
    # Create snapshot for reuse
    snapshot = inst.snapshot_filesystem()
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Dockerfile building is available via the Go API
// For Rust, use pre-built images or snapshots

// Pull base image and customize
let source = client.pull("alpine:3.19", None, None)?;
let inst = Instance::new(source, None)?;
inst.command("apk", &["add", "--no-cache", "curl"])?.run()?;
// Create snapshot for reuse
let snapshot = inst.snapshot(None)?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Dockerfile building is available via the Go API
// For TypeScript, use pre-built images or snapshots

// Pull base image and customize
const source = await client.pull('alpine:3.19');
await using inst = await source.createInstance();
const apkCmd = await inst.command('apk', 'add', '--no-cache', 'curl');
await apkCmd.run();
// Create snapshot for reuse
const snapshot = await inst.snapshotFilesystem();
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Dockerfile building is available via the Go API
// For C, use pre-built images or snapshots

// Pull base image and customize
cc_oci_client_pull(client, "alpine:3.19", NULL, NULL, NULL,
                   CC_HANDLE_INVALID(cc_cancel_token), &source, &err);
cc_instance_new(source, NULL, &inst, &err);
const char* args[] = {"add", "--no-cache", "curl", NULL};
cc_cmd cmd;
cc_cmd_new(inst, "apk", args, &cmd, &err);
int exit_code;
cc_cmd_run(cmd, &exit_code, &err);
// Create snapshot for reuse
```
  </LangTabItem>
</LanguageTabs>

## Building from Dockerfile (Go API)

### Basic Build

<LanguageTabs>
  <LangTabItem lang="go">
```go
client, err := cc.NewOCIClient()
if err != nil {
    return err
}

dockerfile := []byte(`
FROM python:3.12-slim
RUN pip install flask
WORKDIR /app
CMD ["python", "-m", "flask", "run"]
`)

source, err := cc.BuildDockerfileSource(ctx, dockerfile, client)
if err != nil {
    return err
}
defer source.Close()

instance, err := cc.New(source)
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Equivalent using snapshots
with cc.OCIClient() as client:
    source = client.pull("python:3.12-slim")
    with cc.Instance(source) as inst:
        inst.command("pip", "install", "flask").run()
        inst.command("mkdir", "-p", "/app").run()
        snapshot = inst.snapshot_filesystem()

    with cc.Instance(snapshot) as app_inst:
        # Flask is installed
        pass
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Equivalent using snapshots
let client = OciClient::new()?;
let source = client.pull("python:3.12-slim", None, None)?;
let inst = Instance::new(source, None)?;

inst.command("pip", &["install", "flask"])?.run()?;
inst.mkdir("/app", 0o755)?;
let snapshot = inst.snapshot(None)?;

let app_inst = Instance::new(snapshot.into(), None)?;
// Flask is installed
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Equivalent using snapshots
const client = new OCIClient();
const source = await client.pull('python:3.12-slim');

await using inst = await source.createInstance();
const pipCmd = await inst.command('pip', 'install', 'flask');
await pipCmd.run();
await inst.mkdir('/app');
const snapshot = await inst.snapshotFilesystem();

await using appInst = await snapshot.createInstance();
// Flask is installed
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Equivalent using snapshots in C
```
  </LangTabItem>
</LanguageTabs>

### With Build Context

Provide files for COPY/ADD instructions:

<LanguageTabs>
  <LangTabItem lang="go">
```go
source, err := cc.BuildDockerfileSource(ctx, dockerfile, client,
    cc.WithBuildContextDir("/path/to/context"),
)
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Copy files manually
with cc.Instance(source) as inst:
    # Read from host and write to guest
    with open("/path/to/context/app.py", "rb") as f:
        inst.write_file("/app/app.py", f.read())
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Copy files manually
let data = std::fs::read("/path/to/context/app.py")?;
inst.write_file("/app/app.py", &data, 0o644)?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Copy files manually
import * as fs from 'fs';
const data = fs.readFileSync('/path/to/context/app.py');
await inst.writeFile('/app/app.py', data);
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Copy files manually using cc_fs_write_file
```
  </LangTabItem>
</LanguageTabs>

### With Build Arguments

Pass build-time variables:

<LanguageTabs>
  <LangTabItem lang="go">
```go
dockerfile := []byte(`
FROM alpine:3.19
ARG VERSION=1.0.0
RUN echo "Building version $VERSION"
`)

source, err := cc.BuildDockerfileSource(ctx, dockerfile, client,
    cc.WithBuildArg("VERSION", "2.0.0"),
)
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Set environment variables in commands
with cc.Instance(source) as inst:
    cmd = inst.command("sh", "-c", "echo Building version $VERSION")
    cmd.set_env("VERSION", "2.0.0")
    cmd.run()
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Set environment variables in commands
let cmd = inst.command("sh", &["-c", "echo Building version $VERSION"])?
    .env("VERSION", "2.0.0")?;
cmd.run()?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Set environment variables in commands
const cmd = await inst.command('sh', '-c', 'echo Building version $VERSION');
await cmd.setEnv('VERSION', '2.0.0');
await cmd.run();
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Set environment variables via cc_cmd_set_env
```
  </LangTabItem>
</LanguageTabs>

## Supported Instructions

The Dockerfile parser supports these instructions:

| Instruction | Description |
|-------------|-------------|
| `FROM` | Set base image |
| `RUN` | Execute command during build |
| `COPY` | Copy files from build context |
| `ADD` | Add files (with URL and tar extraction support) |
| `ENV` | Set environment variables |
| `ARG` | Define build-time variables |
| `WORKDIR` | Set working directory |
| `USER` | Set user for subsequent commands |
| `CMD` | Set default command |
| `ENTRYPOINT` | Set container entrypoint |
| `EXPOSE` | Document exposed ports |
| `LABEL` | Add metadata labels |

## Example: Build and Run Web App

<LanguageTabs>
  <LangTabItem lang="go">
```go
func buildAndRunApp(appDir string) error {
    client, _ := cc.NewOCIClient()

    dockerfile := []byte(`
FROM node:20-slim
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
`)

    source, err := cc.BuildDockerfileSource(
        context.Background(),
        dockerfile,
        client,
        cc.WithBuildContextDir(appDir),
        cc.WithDockerfileCacheDir(filepath.Join(os.TempDir(), "cc-dockerfile-cache")),
    )
    if err != nil {
        return fmt.Errorf("build failed: %w", err)
    }
    defer source.Close()

    instance, err := cc.New(source, cc.WithMemoryMB(512))
    if err != nil {
        return err
    }
    defer instance.Close()

    // Start the server
    cmd := instance.EntrypointCommand()
    return cmd.Run()
}
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
import os

def build_and_run_app(app_dir):
    with cc.OCIClient() as client:
        source = client.pull("node:20-slim")

        options = cc.InstanceOptions(memory_mb=512)
        with cc.Instance(source, options) as inst:
            # Set up working directory
            inst.mkdir("/app")

            # Copy package.json
            with open(os.path.join(app_dir, "package.json"), "rb") as f:
                inst.write_file("/app/package.json", f.read())

            # Install dependencies
            cmd = inst.command("npm", "install")
            cmd.set_dir("/app")
            cmd.run()

            # Copy app files
            for filename in os.listdir(app_dir):
                filepath = os.path.join(app_dir, filename)
                if os.path.isfile(filepath):
                    with open(filepath, "rb") as f:
                        inst.write_file(f"/app/{filename}", f.read())

            # Start the server
            cmd = inst.command("npm", "start")
            cmd.set_dir("/app")
            cmd.run()
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
fn build_and_run_app(app_dir: &str) -> cc::Result<()> {
    let client = OciClient::new()?;
    let source = client.pull("node:20-slim", None, None)?;

    let opts = InstanceOptions { memory_mb: 512, ..Default::default() };
    let inst = Instance::new(source, Some(opts))?;

    // Set up working directory
    inst.mkdir("/app", 0o755)?;

    // Copy package.json
    let package_json = std::fs::read(format!("{}/package.json", app_dir))?;
    inst.write_file("/app/package.json", &package_json, 0o644)?;

    // Install dependencies
    inst.command("npm", &["install"])?.dir("/app")?.run()?;

    // Copy app files and start
    // ...

    Ok(())
}
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
import * as fs from 'fs';
import * as path from 'path';

async function buildAndRunApp(appDir: string) {
    const client = new OCIClient();
    const source = await client.pull('node:20-slim');

    await using inst = await source.createInstance({ memoryMb: 512 });

    // Set up working directory
    await inst.mkdir('/app');

    // Copy package.json
    const packageJson = fs.readFileSync(path.join(appDir, 'package.json'));
    await inst.writeFile('/app/package.json', packageJson);

    // Install dependencies
    let cmd = await inst.command('npm', 'install');
    await cmd.setDir('/app');
    await cmd.run();

    // Copy app files
    for (const filename of fs.readdirSync(appDir)) {
        const filepath = path.join(appDir, filename);
        if (fs.statSync(filepath).isFile()) {
            const data = fs.readFileSync(filepath);
            await inst.writeFile(`/app/${filename}`, data);
        }
    }

    // Start the server
    cmd = await inst.command('npm', 'start');
    await cmd.setDir('/app');
    await cmd.run();
}
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Similar pattern: pull base image, copy files, run commands
```
  </LangTabItem>
</LanguageTabs>

## Multi-stage Builds (Go API)

Multi-stage builds are supported:

<LanguageTabs>
  <LangTabItem lang="go">
```go
dockerfile := []byte(`
FROM golang:1.22 AS builder
WORKDIR /src
COPY . .
RUN go build -o /app

FROM alpine:3.19
COPY --from=builder /app /usr/local/bin/app
CMD ["app"]
`)

source, err := cc.BuildDockerfileSource(ctx, dockerfile, client,
    cc.WithBuildContextDir("./"),
)
```
  </LangTabItem>
  <LangTabItem lang="python">
```python
# Multi-stage equivalent: use two instances
with cc.OCIClient() as client:
    # Build stage
    builder_source = client.pull("golang:1.22")
    with cc.Instance(builder_source) as builder:
        builder.mkdir("/src")
        # Copy source files
        builder.write_file("/src/main.go", source_code)
        builder.command("go", "build", "-o", "/app").run()
        # Read built binary
        binary = builder.read_file("/app")

    # Runtime stage
    runtime_source = client.pull("alpine:3.19")
    with cc.Instance(runtime_source) as runtime:
        runtime.write_file("/usr/local/bin/app", binary, mode=0o755)
        runtime.command("/usr/local/bin/app").run()
```
  </LangTabItem>
  <LangTabItem lang="rust">
```rust
// Multi-stage equivalent: use two instances
let client = OciClient::new()?;

// Build stage
let builder_source = client.pull("golang:1.22", None, None)?;
let builder = Instance::new(builder_source, None)?;
builder.mkdir("/src", 0o755)?;
builder.write_file("/src/main.go", source_code, 0o644)?;
builder.command("go", &["build", "-o", "/app"])?.run()?;
let binary = builder.read_file("/app")?;

// Runtime stage
let runtime_source = client.pull("alpine:3.19", None, None)?;
let runtime = Instance::new(runtime_source, None)?;
runtime.write_file("/usr/local/bin/app", &binary, 0o755)?;
runtime.command("/usr/local/bin/app", &[])?.run()?;
```
  </LangTabItem>
  <LangTabItem lang="typescript">
```typescript
// Multi-stage equivalent: use two instances
const client = new OCIClient();

// Build stage
const builderSource = await client.pull('golang:1.22');
await using builder = await builderSource.createInstance();
await builder.mkdir('/src');
await builder.writeFile('/src/main.go', Buffer.from(sourceCode));
let cmd = await builder.command('go', 'build', '-o', '/app');
await cmd.run();
const binary = await builder.readFile('/app');

// Runtime stage
const runtimeSource = await client.pull('alpine:3.19');
await using runtime = await runtimeSource.createInstance();
await runtime.writeFile('/usr/local/bin/app', binary, 0o755);
cmd = await runtime.command('/usr/local/bin/app');
await cmd.run();
```
  </LangTabItem>
  <LangTabItem lang="c">
```c
// Multi-stage equivalent: use two instances
// Build in first instance, copy binary to second
```
  </LangTabItem>
</LanguageTabs>

Only the final stage becomes the VM filesystem.

## Limitations

- `HEALTHCHECK` is parsed but not enforced
- `STOPSIGNAL` is parsed but not used
- `SHELL` instruction is not supported (always uses `/bin/sh -c`)
- Build secrets are not supported

## Next Steps

- [Snapshots](/cc/api/snapshots/) - Cache built images as snapshots
- [Creating Instances](/cc/api/creating-instances/) - Start VMs from Dockerfile builds
